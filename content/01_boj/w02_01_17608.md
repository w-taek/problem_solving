##### 문제번호 [17608]

---

# BOJ 17608 복습 노트

## 1) 핵심 모델링(10초)
- **관점 고정:** 오른쪽에서 본다 → **오른쪽 끝부터 스캔**
- **보이는 조건:** `현재 높이 > (지금까지의 최대 높이)`
- **상태값:** 최대 높이 `max_so_far` 하나면 충분  
  - (스택 풀이와 동일한 효과를 `max_so_far`로 압축)

---

## 2) 불변식(Invariant)
- 반복 중 항상 유지:
  - `max_so_far` = 현재까지 스캔한 구간의 **최대 높이**
- 갱신 규칙:
  - `if h > max_so_far:`  
    `count += 1`, `max_so_far = h`

---

## 3) 입력 템플릿(실수 방지)
```python
import sys
input = sys.stdin.readline

n = int(input())
sticks = [int(input()) for _ in range(n)]
```
- `readline`은 반드시 호출: `readline()`
  - `readline`(괄호 없음)은 함수 객체
- 정수 입력은 `int()`가 `\n` 포함 문자열도 처리 가능 → `strip()` 필수 아님

## 1) 구현 습관(오답/시간초과 예방)
- 리스트를 뒤집지 말고 역순 순회:
```python
for h in reversed(sticks):
    ...
```
- 제출 전 디버그 출력 제거(출력 형식 오염)

## 5) 자주 터지는 포인트 체크

- `int(sys.stdin.readline)` ❌ / `int(sys.stdin.readline())` ✅
- `strip()`은 원본을 바꾸지 않음(반환값 사용 필요)
- “첫 줄 N” 문제에서 `EOF while`을 섞지 않기(추가 입력 섞여 오답 위험)

## 6) 최종 코드 스켈레톤(정석)
```python
import sys
input = sys.stdin.readline

n = int(input())
sticks = [int(input()) for _ in range(n)]

max_so_far = -1
count = 0
for h in reversed(sticks):
    if h > max_so_far:
        max_so_far = h
        count += 1

print(count)
```
---

# 막대기

| 시간 제한 (s) | 메모리 제한 (MB) | 정답률 (%) |
| --- | --- | ---|
| 1 | 512 | 43.133 |

## 문제
아래 그림처럼 높이만 다르고 (같은 높이의 막대기가 있을 수 있음) 모양이 같은 막대기를 일렬로 세운 후, 왼쪽부터 차례로 번호를 붙인다. 각 막대기의 높이는 그림에서 보인 것처럼 순서대로 6, 9, 7, 6, 4, 6 이다. 일렬로 세워진 막대기를 오른쪽에서 보면 보이는 막대기가 있고 보이지 않는 막대기가 있다. 즉, 지금 보이는 막대기보다 뒤에 있고 높이가 높은 것이 보이게 된다. 예를 들어, 그림과 같은 경우엔 3개(6번, 3번, 2번)의 막대기가 보인다.

![alt text](Attached_img/17608.png)

N개의 막대기에 대한 높이 정보가 주어질 때, 오른쪽에서 보아서 몇 개가 보이는지를 알아내는 프로그램을 작성하려고 한다.


## 입력
첫 번째 줄에는 막대기의 개수를 나타내는 정수 N (2 ≤ N ≤ 100,000)이 주어지고 이어지는 N줄 각각에는 막대기의 높이를 나타내는 정수 h(1 ≤ h ≤ 100,000)가 주어진다.



## 출력
오른쪽에서 N개의 막대기를 보았을 때, 보이는 막대기의 개수를 출력한다.



## 예제 입력 1
```
6
6
9
7
6
4
6
```

## 예제 출력 1
```
3
```

## 예제 입력 2
```
5
5
4
3
2
1
```

## 예제 출력 2
```
5
```
