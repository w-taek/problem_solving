---
draft: "true"
---

##### 문제번호 [26042]

---

1. deq을 쓴 이유?
2. 

---

## 📝 Problem Solving 복습 노트: [26042] 식당 입구 대기 줄

### 1. 핵심 학습 포인트
* **자료구조의 선택 (Vector vs Deque)**
    - `std::vector::erase(begin)`은 $O(N)$의 시간 복잡도를 가짐 (모든 원소 이동).
    - `std::deque::pop_front()`는 $O(1)$로 맨 앞 원소 삭제 가능.
    - **결론:** 선입선출(FIFO)이 빈번한 구조에서는 `deque`나 `queue`가 압도적으로 유리함.

* **효율적인 상태 관리 (Memory & Time Optimization)**
    - "최대 순간"을 기록하기 위해 전체 구조(`vector`)를 복사하는 대신, 필요한 **핵심 지표(Count, Last ID)**만 변수로 관리하여 $O(1)$로 최적화.

* **C++ 성능 최적화 (Fast I/O)**
    - $N \ge 10^5$이고 시간 제한이 짧을 때(0.1s~0.5s), `ios_base::sync_with_stdio(false); cin.tie(NULL);`은 선택이 아닌 필수.

### 2. 코드 구조 및 테크닉
* **매개변수 전달:** `const T&`를 사용하여 대형 객체 복사 방지.
* **size_t 사용:** 컨테이너의 크기 비교 시 부호 없는 정수형(`size_t`)을 사용하여 타입 안정성 확보.
* **비교 로직:** 1. `current.size > max`: 무조건 갱신.
  2. `current.size == max`: 문제 조건(ID 최소값)에 따라 선별적 갱신.

### 3. 더 나아가기 (Self-Reflect)
- [ ] **학생 번호를 다 저장해야만 할까?** - 사실 유형 2가 나올 때마다 단순히 `count--`만 해도 학생 수는 추적 가능함. 
  - 하지만 "최대일 때의 맨 뒤 학생 번호"를 알기 위해서는 `push`되는 학생을 순서대로 기록해야 하므로 `deque` 사용은 적절한 선택이었음.
- [ ] **에러 방지:** `line.pop_front()`를 하기 전, `line.empty()` 체크를 하는 습관이 디버깅에 유리함 (단, 이 문제에서는 항상 학생이 존재한다는 조건이 있음).

### 4. 다음에 활용할 Snippet
```cpp
#include <iostream>
#include <deque>

using namespace std;

int main() {
    // 0.1초 제한을 뚫는 마법의 주문
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    // ... 로직 구현 ...
    return 0;
}
```

---

# 식당 입구 대기 줄

| 시간 제한 (s) | 메모리 제한 (MB) | 정답률 (%) |
| --- | --- | ---|
| 0.1 | 512 | 33.922 |

## 문제
여러 명의 학생이 식사하기 위하여 학교 식당을 향해 달려가고 있다. 학교 식당에 도착한 학생은 식당 입구에 줄을 서서 대기한다. 학교 식당에 먼저 도착한 학생이 나중에 도착한 학생보다 식당 입구의 앞쪽에서 대기한다. 식사는 1인분씩 준비된다. 식사 1인분이 준비되면 식당 입구의 맨 앞에서 대기 중인 학생 1명이 식당으로 들어가서 식사를 시작한다. 식사를 시작한 학생은 항상 식사를 마친다.

학생이 학교 식당에 도착하고 식사가 준비되는 n개의 정보가 저장된 A가 주어진다. A에 저장된 첫 번째 정보부터 n번째 정보까지 순서대로 처리한 다음, 식당 입구에 줄을 서서 대기하는 학생 수가 최대가 되었던 순간의 학생 수와 이때 식당 입구의 맨 뒤에 대기 중인 학생의 번호를 출력하자. 대기하는 학생 수가 최대인 경우가 여러 번이라면 맨 뒤에 줄 서 있는 학생의 번호가 가장 작은 경우를 출력하자.

A에 저장된 n개의 정보는 아래 두 가지 유형으로 구분된다. 첫 번째가 유형 1, 두 번째가 유형 2이다.

1 a: 학생 번호가 양의 정수 a인 학생 1명이 학교 식당에 도착하여 식당 입구의 맨 뒤에 줄을 서기 시작한다.
2: 식사 1인분이 준비되어 식당 입구의 맨 앞에서 대기 중인 학생 1명이 식사를 시작한다.
식사 1인분이 준비될 때는 식당 입구에서 대기 중인 학생이 항상 존재한다. 식당 입구에 줄을 서서 대기하였으나 식사가 준비 안 된 학생은 식사를 못 한다.

## 입력
첫 번째 줄에 n이 주어진다.

다음 줄부터 n개의 줄에 걸쳐 한 줄에 하나의 정보가 주어진다. 주어지는 정보는 유형 1, 2중 하나이다.

## 출력
첫 번째 정보부터 n번째 정보까지 순서대로 처리한 다음, 식당 입구에 줄을 서서 대기하는 학생 수가 최대가 되었던 순간의 학생 수와 이때 식당 입구의 맨 뒤에 대기 중인 학생의 번호를 빈칸을 사이에 두고 순서대로 출력한다. 대기하는 학생 수가 최대인 경우가 여러 번이라면 맨 뒤에 줄 서 있는 학생의 번호가 가장 작은 경우를 출력한다.

## 제한
- 1 ≤ n ≤ 100,000
- A에는 유형 1, 유형 2만 저장되어 있다.
- 1 ≤ a ≤ n, 모든 양의 정수 a의 값은 서로 다르다.

## 예제 입력 1
```
5
1 2
1 1
2
1 3
2
```

## 예제 출력 1
```
2 1
```
첫 번째 1 2를 처리한 후, 대기 줄은 2가 된다.

두 번째 1 1을 처리한 후, 대기 줄은 2 1이 된다. 대기줄 2 1은 2번 학생이 앞쪽, 1번 학생이 뒤쪽에서 대기 중임을 의미낸다.

세 번째 2를 처리한 후, 앞쪽에서 대기 중인 2번 학생이 대기 줄을 나와서 식사를 하므로 대기 줄은 1이 된다.

네 번째 1 3을 처리한 후, 대기 줄은 1 3이 된다.

다섯 번째 2를 처리한 후, 앞쪽에서 대기 중인 1번 학생이 대기 줄을 나와서 식사를 하므로 대기 줄은 3이 된다. 

다섯 개의 정보를 처리하는 동안 대기 줄에 대기하는 학생 수의 최댓값은 2이다. 학생 수가 2인 대기 줄은 '2 1', '1 3' 두 가지이며, 맨 뒤에 줄 서 있는 학생 번호가 가장 작은 경우는 ‘2 1’이다.

## 예제 입력 2
```

```

## 예제 출력 2
```

```
